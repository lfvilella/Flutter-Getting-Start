{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/Users/felipe/projects/lucy-farm/AwesomeProject/node_modules/react-navigation/src/views/CardStack/CardStack.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport clamp from 'clamp';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport PanResponder from \"react-native-web/dist/exports/PanResponder\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport View from \"react-native-web/dist/exports/View\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport Card from \"./Card\";\nimport Header from \"../Header/Header\";\nimport NavigationActions from \"../../NavigationActions\";\nimport addNavigationHelpers from \"../../addNavigationHelpers\";\nimport getChildEventSubscriber from \"../../getChildEventSubscriber\";\nimport SceneView from \"../SceneView\";\nimport TransitionConfigs from \"./TransitionConfigs\";\nimport * as ReactNativeFeatures from \"../../utils/ReactNativeFeatures\";\n\nvar emptyFunction = function emptyFunction() {};\n\nvar EaseInOut = Easing.inOut(Easing.ease);\nvar ANIMATION_DURATION = 500;\nvar POSITION_THRESHOLD = 1 / 2;\nvar RESPOND_THRESHOLD = 20;\nvar GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 25;\nvar GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\n\nvar animatedSubscribeValue = function animatedSubscribeValue(animatedValue) {\n  if (!animatedValue.__isNative) {\n    return;\n  }\n\n  if (Object.keys(animatedValue._listeners).length === 0) {\n    animatedValue.addListener(emptyFunction);\n  }\n};\n\nvar CardStack = function (_React$Component) {\n  _inherits(CardStack, _React$Component);\n\n  var _super = _createSuper(CardStack);\n\n  function CardStack() {\n    var _this;\n\n    _classCallCheck(this, CardStack);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this._gestureStartValue = 0;\n    _this._isResponding = false;\n    _this._immediateIndex = null;\n    _this._screenDetails = {};\n    _this._childEventSubscribers = {};\n\n    _this._isRouteFocused = function (route) {\n      var state = _this.props.navigation.state;\n      var focusedRoute = state.routes[state.index];\n      return route === focusedRoute;\n    };\n\n    _this._getScreenDetails = function (scene) {\n      var _this$props = _this.props,\n          screenProps = _this$props.screenProps,\n          navigation = _this$props.transitionProps.navigation,\n          router = _this$props.router;\n      var screenDetails = _this._screenDetails[scene.key];\n\n      if (!screenDetails || screenDetails.state !== scene.route) {\n        if (!_this._childEventSubscribers[scene.route.key]) {\n          _this._childEventSubscribers[scene.route.key] = getChildEventSubscriber(navigation.addListener, scene.route.key);\n        }\n\n        var screenNavigation = addNavigationHelpers({\n          dispatch: navigation.dispatch,\n          state: scene.route,\n          isFocused: _this._isRouteFocused.bind(_assertThisInitialized(_this), scene.route),\n          addListener: _this._childEventSubscribers[scene.route.key]\n        });\n        screenDetails = {\n          state: scene.route,\n          navigation: screenNavigation,\n          options: router.getScreenOptions(screenNavigation, screenProps)\n        };\n        _this._screenDetails[scene.key] = screenDetails;\n      }\n\n      return screenDetails;\n    };\n\n    _this._getTransitionConfig = function () {\n      var isModal = _this.props.mode === 'modal';\n      return TransitionConfigs.getTransitionConfig(_this.props.transitionConfig, _this.props.transitionProps, _this.props.prevTransitionProps, isModal);\n    };\n\n    _this._renderCard = function (scene) {\n      var _this$_getTransitionC = _this._getTransitionConfig(),\n          screenInterpolator = _this$_getTransitionC.screenInterpolator;\n\n      var style = screenInterpolator && screenInterpolator(_objectSpread(_objectSpread({}, _this.props.transitionProps), {}, {\n        scene: scene\n      }));\n\n      var SceneComponent = _this.props.router.getComponentForRouteName(scene.route.routeName);\n\n      var _this$props2 = _this.props,\n          transitionProps = _this$props2.transitionProps,\n          props = _objectWithoutProperties(_this$props2, [\"transitionProps\"]);\n\n      return React.createElement(Card, _extends({}, props, transitionProps, {\n        key: \"card_\" + scene.key,\n        style: [style, _this.props.cardStyle],\n        scene: scene,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 498,\n          columnNumber: 7\n        }\n      }), _this._renderInnerScene(SceneComponent, scene));\n    };\n\n    return _this;\n  }\n\n  _createClass(CardStack, [{\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(props) {\n      var _this2 = this;\n\n      if (props.screenProps !== this.props.screenProps) {\n        this._screenDetails = {};\n      }\n\n      props.transitionProps.scenes.forEach(function (newScene) {\n        if (_this2._screenDetails[newScene.key] && _this2._screenDetails[newScene.key].state !== newScene.route) {\n          _this2._screenDetails[newScene.key] = null;\n        }\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var _this3 = this;\n\n      var activeKeys = this.props.transitionProps.navigation.state.routes.map(function (route) {\n        return route.key;\n      });\n      Object.keys(this._childEventSubscribers).forEach(function (key) {\n        if (!activeKeys.includes(key)) {\n          delete _this3._childEventSubscribers[key];\n        }\n      });\n    }\n  }, {\n    key: \"_renderHeader\",\n    value: function _renderHeader(scene, headerMode) {\n      var header = this._getScreenDetails(scene).options.header;\n\n      if (typeof header !== 'undefined' && typeof header !== 'function') {\n        return header;\n      }\n\n      var renderHeader = header || function (props) {\n        return React.createElement(Header, _extends({}, props, {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 152,\n            columnNumber: 46\n          }\n        }));\n      };\n\n      var _this$_getTransitionC2 = this._getTransitionConfig(),\n          headerLeftInterpolator = _this$_getTransitionC2.headerLeftInterpolator,\n          headerTitleInterpolator = _this$_getTransitionC2.headerTitleInterpolator,\n          headerRightInterpolator = _this$_getTransitionC2.headerRightInterpolator;\n\n      var _this$props3 = this.props,\n          mode = _this$props3.mode,\n          transitionProps = _this$props3.transitionProps,\n          prevTransitionProps = _this$props3.prevTransitionProps,\n          passProps = _objectWithoutProperties(_this$props3, [\"mode\", \"transitionProps\", \"prevTransitionProps\"]);\n\n      return renderHeader(_objectSpread(_objectSpread(_objectSpread({}, passProps), transitionProps), {}, {\n        scene: scene,\n        mode: headerMode,\n        transitionPreset: this._getHeaderTransitionPreset(),\n        getScreenDetails: this._getScreenDetails,\n        leftInterpolator: headerLeftInterpolator,\n        titleInterpolator: headerTitleInterpolator,\n        rightInterpolator: headerRightInterpolator\n      }));\n    }\n  }, {\n    key: \"_animatedSubscribe\",\n    value: function _animatedSubscribe(props) {\n      animatedSubscribeValue(props.transitionProps.layout.width);\n      animatedSubscribeValue(props.transitionProps.layout.height);\n      animatedSubscribeValue(props.transitionProps.position);\n    }\n  }, {\n    key: \"_reset\",\n    value: function _reset(resetToIndex, duration) {\n      if (Platform.OS === 'ios' && ReactNativeFeatures.supportsImprovedSpringAnimation()) {\n        Animated.spring(this.props.transitionProps.position, {\n          toValue: resetToIndex,\n          stiffness: 5000,\n          damping: 600,\n          mass: 3,\n          useNativeDriver: this.props.transitionProps.position.__isNative\n        }).start();\n      } else {\n        Animated.timing(this.props.transitionProps.position, {\n          toValue: resetToIndex,\n          duration: duration,\n          easing: EaseInOut,\n          useNativeDriver: this.props.transitionProps.position.__isNative\n        }).start();\n      }\n    }\n  }, {\n    key: \"_goBack\",\n    value: function _goBack(backFromIndex, duration) {\n      var _this4 = this;\n\n      var _this$props$transitio = this.props.transitionProps,\n          navigation = _this$props$transitio.navigation,\n          position = _this$props$transitio.position,\n          scenes = _this$props$transitio.scenes;\n      var toValue = Math.max(backFromIndex - 1, 0);\n      this._immediateIndex = toValue;\n\n      var onCompleteAnimation = function onCompleteAnimation() {\n        _this4._immediateIndex = null;\n        var backFromScene = scenes.find(function (s) {\n          return s.index === toValue + 1;\n        });\n\n        if (!_this4._isResponding && backFromScene) {\n          navigation.dispatch(NavigationActions.back({\n            key: backFromScene.route.key,\n            immediate: true\n          }));\n        }\n      };\n\n      if (Platform.OS === 'ios' && ReactNativeFeatures.supportsImprovedSpringAnimation()) {\n        Animated.spring(position, {\n          toValue: toValue,\n          stiffness: 5000,\n          damping: 600,\n          mass: 3,\n          useNativeDriver: position.__isNative\n        }).start(onCompleteAnimation);\n      } else {\n        Animated.timing(position, {\n          toValue: toValue,\n          duration: duration,\n          easing: EaseInOut,\n          useNativeDriver: position.__isNative\n        }).start(onCompleteAnimation);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      var floatingHeader = null;\n\n      var headerMode = this._getHeaderMode();\n\n      if (headerMode === 'float') {\n        floatingHeader = this._renderHeader(this.props.transitionProps.scene, headerMode);\n      }\n\n      var _this$props4 = this.props,\n          _this$props4$transiti = _this$props4.transitionProps,\n          navigation = _this$props4$transiti.navigation,\n          position = _this$props4$transiti.position,\n          layout = _this$props4$transiti.layout,\n          scene = _this$props4$transiti.scene,\n          scenes = _this$props4$transiti.scenes,\n          mode = _this$props4.mode;\n      var index = navigation.state.index;\n      var isVertical = mode === 'modal';\n\n      var _this$_getScreenDetai = this._getScreenDetails(scene),\n          options = _this$_getScreenDetai.options;\n\n      var gestureDirectionInverted = options.gestureDirection === 'inverted';\n      var gesturesEnabled = typeof options.gesturesEnabled === 'boolean' ? options.gesturesEnabled : Platform.OS === 'ios';\n      var responder = !gesturesEnabled ? null : PanResponder.create({\n        onPanResponderTerminate: function onPanResponderTerminate() {\n          _this5._isResponding = false;\n\n          _this5._reset(index, 0);\n        },\n        onPanResponderGrant: function onPanResponderGrant() {\n          position.stopAnimation(function (value) {\n            _this5._isResponding = true;\n            _this5._gestureStartValue = value;\n          });\n        },\n        onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder(event, gesture) {\n          if (index !== scene.index) {\n            return false;\n          }\n\n          var immediateIndex = _this5._immediateIndex == null ? index : _this5._immediateIndex;\n          var currentDragDistance = gesture[isVertical ? 'dy' : 'dx'];\n          var currentDragPosition = event.nativeEvent[isVertical ? 'pageY' : 'pageX'];\n          var axisLength = isVertical ? layout.height.__getValue() : layout.width.__getValue();\n          var axisHasBeenMeasured = !!axisLength;\n          var screenEdgeDistance = gestureDirectionInverted ? axisLength - (currentDragPosition - currentDragDistance) : currentDragPosition - currentDragDistance;\n\n          var _this5$_getScreenDeta = _this5._getScreenDetails(scene).options.gestureResponseDistance,\n              userGestureResponseDistance = _this5$_getScreenDeta === void 0 ? {} : _this5$_getScreenDeta;\n\n          var gestureResponseDistance = isVertical ? userGestureResponseDistance.vertical || GESTURE_RESPONSE_DISTANCE_VERTICAL : userGestureResponseDistance.horizontal || GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n\n          if (screenEdgeDistance > gestureResponseDistance) {\n            return false;\n          }\n\n          var hasDraggedEnough = Math.abs(currentDragDistance) > RESPOND_THRESHOLD;\n          var isOnFirstCard = immediateIndex === 0;\n          var shouldSetResponder = hasDraggedEnough && axisHasBeenMeasured && !isOnFirstCard;\n          return shouldSetResponder;\n        },\n        onPanResponderMove: function onPanResponderMove(event, gesture) {\n          var startValue = _this5._gestureStartValue;\n          var axis = isVertical ? 'dy' : 'dx';\n          var axisDistance = isVertical ? layout.height.__getValue() : layout.width.__getValue();\n          var currentValue = (I18nManager.isRTL && axis === 'dx') !== gestureDirectionInverted ? startValue + gesture[axis] / axisDistance : startValue - gesture[axis] / axisDistance;\n          var value = clamp(index - 1, currentValue, index);\n          position.setValue(value);\n        },\n        onPanResponderTerminationRequest: function onPanResponderTerminationRequest() {\n          return false;\n        },\n        onPanResponderRelease: function onPanResponderRelease(event, gesture) {\n          if (!_this5._isResponding) {\n            return;\n          }\n\n          _this5._isResponding = false;\n          var immediateIndex = _this5._immediateIndex == null ? index : _this5._immediateIndex;\n          var axisDistance = isVertical ? layout.height.__getValue() : layout.width.__getValue();\n          var movementDirection = gestureDirectionInverted ? -1 : 1;\n          var movedDistance = movementDirection * gesture[isVertical ? 'dy' : 'dx'];\n          var gestureVelocity = movementDirection * gesture[isVertical ? 'vy' : 'vx'];\n          var defaultVelocity = axisDistance / ANIMATION_DURATION;\n          var velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n          var resetDuration = gestureDirectionInverted ? (axisDistance - movedDistance) / velocity : movedDistance / velocity;\n          var goBackDuration = gestureDirectionInverted ? movedDistance / velocity : (axisDistance - movedDistance) / velocity;\n          position.stopAnimation(function (value) {\n            if (gestureVelocity < -0.5) {\n              _this5._reset(immediateIndex, resetDuration);\n\n              return;\n            }\n\n            if (gestureVelocity > 0.5) {\n              _this5._goBack(immediateIndex, goBackDuration);\n\n              return;\n            }\n\n            if (value <= index - POSITION_THRESHOLD) {\n              _this5._goBack(immediateIndex, goBackDuration);\n            } else {\n              _this5._reset(immediateIndex, resetDuration);\n            }\n          });\n        }\n      });\n      var handlers = gesturesEnabled ? responder.panHandlers : {};\n      var containerStyle = [styles.container, this._getTransitionConfig().containerStyle];\n      return React.createElement(View, _extends({}, handlers, {\n        style: containerStyle,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 413,\n          columnNumber: 7\n        }\n      }), React.createElement(View, {\n        style: styles.scenes,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 414,\n          columnNumber: 9\n        }\n      }, scenes.map(function (s) {\n        return _this5._renderCard(s);\n      })), floatingHeader);\n    }\n  }, {\n    key: \"_getHeaderMode\",\n    value: function _getHeaderMode() {\n      if (this.props.headerMode) {\n        return this.props.headerMode;\n      }\n\n      if (Platform.OS === 'android' || this.props.mode === 'modal') {\n        return 'screen';\n      }\n\n      return 'float';\n    }\n  }, {\n    key: \"_getHeaderTransitionPreset\",\n    value: function _getHeaderTransitionPreset() {\n      if (Platform.OS === 'android' || this._getHeaderMode() === 'screen') {\n        return 'fade-in-place';\n      }\n\n      if (this.props.headerTransitionPreset) {\n        return this.props.headerTransitionPreset;\n      } else {\n        return 'fade-in-place';\n      }\n    }\n  }, {\n    key: \"_renderInnerScene\",\n    value: function _renderInnerScene(SceneComponent, scene) {\n      var _this$_getScreenDetai2 = this._getScreenDetails(scene),\n          navigation = _this$_getScreenDetai2.navigation;\n\n      var screenProps = this.props.screenProps;\n\n      var headerMode = this._getHeaderMode();\n\n      if (headerMode === 'screen') {\n        return React.createElement(View, {\n          style: styles.container,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 453,\n            columnNumber: 9\n          }\n        }, React.createElement(View, {\n          style: {\n            flex: 1\n          },\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 454,\n            columnNumber: 11\n          }\n        }, React.createElement(SceneView, {\n          screenProps: screenProps,\n          navigation: navigation,\n          component: SceneComponent,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 455,\n            columnNumber: 13\n          }\n        })), this._renderHeader(scene, headerMode));\n      }\n\n      return React.createElement(SceneView, {\n        screenProps: this.props.screenProps,\n        navigation: navigation,\n        component: SceneComponent,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 466,\n          columnNumber: 7\n        }\n      });\n    }\n  }]);\n\n  return CardStack;\n}(React.Component);\n\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    flexDirection: 'column-reverse'\n  },\n  scenes: {\n    flex: 1\n  }\n});\nexport default CardStack;","map":{"version":3,"sources":["/Users/felipe/projects/lucy-farm/AwesomeProject/node_modules/react-navigation/src/views/CardStack/CardStack.js"],"names":["React","clamp","Card","Header","NavigationActions","addNavigationHelpers","getChildEventSubscriber","SceneView","TransitionConfigs","ReactNativeFeatures","emptyFunction","EaseInOut","Easing","inOut","ease","ANIMATION_DURATION","POSITION_THRESHOLD","RESPOND_THRESHOLD","GESTURE_RESPONSE_DISTANCE_HORIZONTAL","GESTURE_RESPONSE_DISTANCE_VERTICAL","animatedSubscribeValue","animatedValue","__isNative","Object","keys","_listeners","length","addListener","CardStack","_gestureStartValue","_isResponding","_immediateIndex","_screenDetails","_childEventSubscribers","_isRouteFocused","route","state","props","navigation","focusedRoute","routes","index","_getScreenDetails","scene","screenProps","transitionProps","router","screenDetails","key","screenNavigation","dispatch","isFocused","bind","options","getScreenOptions","_getTransitionConfig","isModal","mode","getTransitionConfig","transitionConfig","prevTransitionProps","_renderCard","screenInterpolator","style","SceneComponent","getComponentForRouteName","routeName","cardStyle","_renderInnerScene","scenes","forEach","newScene","activeKeys","map","includes","headerMode","header","renderHeader","headerLeftInterpolator","headerTitleInterpolator","headerRightInterpolator","passProps","transitionPreset","_getHeaderTransitionPreset","getScreenDetails","leftInterpolator","titleInterpolator","rightInterpolator","layout","width","height","position","resetToIndex","duration","Platform","OS","supportsImprovedSpringAnimation","Animated","spring","toValue","stiffness","damping","mass","useNativeDriver","start","timing","easing","backFromIndex","Math","max","onCompleteAnimation","backFromScene","find","s","back","immediate","floatingHeader","_getHeaderMode","_renderHeader","isVertical","gestureDirectionInverted","gestureDirection","gesturesEnabled","responder","PanResponder","create","onPanResponderTerminate","_reset","onPanResponderGrant","stopAnimation","value","onMoveShouldSetPanResponder","event","gesture","immediateIndex","currentDragDistance","currentDragPosition","nativeEvent","axisLength","__getValue","axisHasBeenMeasured","screenEdgeDistance","gestureResponseDistance","userGestureResponseDistance","vertical","horizontal","hasDraggedEnough","abs","isOnFirstCard","shouldSetResponder","onPanResponderMove","startValue","axis","axisDistance","currentValue","I18nManager","isRTL","setValue","onPanResponderTerminationRequest","onPanResponderRelease","movementDirection","movedDistance","gestureVelocity","defaultVelocity","velocity","resetDuration","goBackDuration","_goBack","handlers","panHandlers","containerStyle","styles","container","headerTransitionPreset","flex","Component","StyleSheet","flexDirection"],"mappings":"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","sourcesContent":["import React from 'react';\n\nimport clamp from 'clamp';\nimport {\n  Animated,\n  StyleSheet,\n  PanResponder,\n  Platform,\n  View,\n  I18nManager,\n  Easing,\n} from 'react-native';\n\nimport Card from './Card';\nimport Header from '../Header/Header';\nimport NavigationActions from '../../NavigationActions';\nimport addNavigationHelpers from '../../addNavigationHelpers';\nimport getChildEventSubscriber from '../../getChildEventSubscriber';\nimport SceneView from '../SceneView';\n\nimport TransitionConfigs from './TransitionConfigs';\nimport * as ReactNativeFeatures from '../../utils/ReactNativeFeatures';\n\nconst emptyFunction = () => {};\n\nconst EaseInOut = Easing.inOut(Easing.ease);\n\n/**\n * The max duration of the card animation in milliseconds after released gesture.\n * The actual duration should be always less then that because the rest distance\n * is always less then the full distance of the layout.\n */\nconst ANIMATION_DURATION = 500;\n\n/**\n * The gesture distance threshold to trigger the back behavior. For instance,\n * `1/2` means that moving greater than 1/2 of the width of the screen will\n * trigger a back action\n */\nconst POSITION_THRESHOLD = 1 / 2;\n\n/**\n * The threshold (in pixels) to start the gesture action.\n */\nconst RESPOND_THRESHOLD = 20;\n\n/**\n * The distance of touch start from the edge of the screen where the gesture will be recognized\n */\nconst GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 25;\nconst GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\n\nconst animatedSubscribeValue = animatedValue => {\n  if (!animatedValue.__isNative) {\n    return;\n  }\n  if (Object.keys(animatedValue._listeners).length === 0) {\n    animatedValue.addListener(emptyFunction);\n  }\n};\n\nclass CardStack extends React.Component {\n  /**\n   * Used to identify the starting point of the position when the gesture starts, such that it can\n   * be updated according to its relative position. This means that a card can effectively be\n   * \"caught\"- If a gesture starts while a card is animating, the card does not jump into a\n   * corresponding location for the touch.\n   */\n  _gestureStartValue = 0;\n\n  // tracks if a touch is currently happening\n  _isResponding = false;\n\n  /**\n   * immediateIndex is used to represent the expected index that we will be on after a\n   * transition. To achieve a smooth animation when swiping back, the action to go back\n   * doesn't actually fire until the transition completes. The immediateIndex is used during\n   * the transition so that gestures can be handled correctly. This is a work-around for\n   * cases when the user quickly swipes back several times.\n   */\n  _immediateIndex = null;\n\n  _screenDetails = {};\n\n  _childEventSubscribers = {};\n\n  componentWillReceiveProps(props) {\n    if (props.screenProps !== this.props.screenProps) {\n      this._screenDetails = {};\n    }\n    props.transitionProps.scenes.forEach(newScene => {\n      if (\n        this._screenDetails[newScene.key] &&\n        this._screenDetails[newScene.key].state !== newScene.route\n      ) {\n        this._screenDetails[newScene.key] = null;\n      }\n    });\n  }\n\n  componentDidUpdate() {\n    const activeKeys = this.props.transitionProps.navigation.state.routes.map(\n      route => route.key\n    );\n    Object.keys(this._childEventSubscribers).forEach(key => {\n      if (!activeKeys.includes(key)) {\n        delete this._childEventSubscribers[key];\n      }\n    });\n  }\n\n  _isRouteFocused = route => {\n    const { state } = this.props.navigation;\n    const focusedRoute = state.routes[state.index];\n    return route === focusedRoute;\n  };\n\n  _getScreenDetails = scene => {\n    const { screenProps, transitionProps: { navigation }, router } = this.props;\n    let screenDetails = this._screenDetails[scene.key];\n    if (!screenDetails || screenDetails.state !== scene.route) {\n      if (!this._childEventSubscribers[scene.route.key]) {\n        this._childEventSubscribers[scene.route.key] = getChildEventSubscriber(\n          navigation.addListener,\n          scene.route.key\n        );\n      }\n\n      const screenNavigation = addNavigationHelpers({\n        dispatch: navigation.dispatch,\n        state: scene.route,\n        isFocused: this._isRouteFocused.bind(this, scene.route),\n        addListener: this._childEventSubscribers[scene.route.key],\n      });\n      screenDetails = {\n        state: scene.route,\n        navigation: screenNavigation,\n        options: router.getScreenOptions(screenNavigation, screenProps),\n      };\n      this._screenDetails[scene.key] = screenDetails;\n    }\n    return screenDetails;\n  };\n\n  _renderHeader(scene, headerMode) {\n    const { header } = this._getScreenDetails(scene).options;\n\n    if (typeof header !== 'undefined' && typeof header !== 'function') {\n      return header;\n    }\n\n    const renderHeader = header || (props => <Header {...props} />);\n    const {\n      headerLeftInterpolator,\n      headerTitleInterpolator,\n      headerRightInterpolator,\n    } = this._getTransitionConfig();\n\n    const {\n      mode,\n      transitionProps,\n      prevTransitionProps,\n      ...passProps\n    } = this.props;\n\n    return renderHeader({\n      ...passProps,\n      ...transitionProps,\n      scene,\n      mode: headerMode,\n      transitionPreset: this._getHeaderTransitionPreset(),\n      getScreenDetails: this._getScreenDetails,\n      leftInterpolator: headerLeftInterpolator,\n      titleInterpolator: headerTitleInterpolator,\n      rightInterpolator: headerRightInterpolator,\n    });\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _animatedSubscribe(props) {\n    // Hack to make this work with native driven animations. We add a single listener\n    // so the JS value of the following animated values gets updated. We rely on\n    // some Animated private APIs and not doing so would require using a bunch of\n    // value listeners but we'd have to remove them to not leak and I'm not sure\n    // when we'd do that with the current structure we have. `stopAnimation` callback\n    // is also broken with native animated values that have no listeners so if we\n    // want to remove this we have to fix this too.\n    animatedSubscribeValue(props.transitionProps.layout.width);\n    animatedSubscribeValue(props.transitionProps.layout.height);\n    animatedSubscribeValue(props.transitionProps.position);\n  }\n\n  _reset(resetToIndex, duration) {\n    if (\n      Platform.OS === 'ios' &&\n      ReactNativeFeatures.supportsImprovedSpringAnimation()\n    ) {\n      Animated.spring(this.props.transitionProps.position, {\n        toValue: resetToIndex,\n        stiffness: 5000,\n        damping: 600,\n        mass: 3,\n        useNativeDriver: this.props.transitionProps.position.__isNative,\n      }).start();\n    } else {\n      Animated.timing(this.props.transitionProps.position, {\n        toValue: resetToIndex,\n        duration,\n        easing: EaseInOut,\n        useNativeDriver: this.props.transitionProps.position.__isNative,\n      }).start();\n    }\n  }\n\n  _goBack(backFromIndex, duration) {\n    const { navigation, position, scenes } = this.props.transitionProps;\n    const toValue = Math.max(backFromIndex - 1, 0);\n\n    // set temporary index for gesture handler to respect until the action is\n    // dispatched at the end of the transition.\n    this._immediateIndex = toValue;\n\n    const onCompleteAnimation = () => {\n      this._immediateIndex = null;\n      const backFromScene = scenes.find(s => s.index === toValue + 1);\n      if (!this._isResponding && backFromScene) {\n        navigation.dispatch(\n          NavigationActions.back({\n            key: backFromScene.route.key,\n            immediate: true,\n          })\n        );\n      }\n    };\n\n    if (\n      Platform.OS === 'ios' &&\n      ReactNativeFeatures.supportsImprovedSpringAnimation()\n    ) {\n      Animated.spring(position, {\n        toValue,\n        stiffness: 5000,\n        damping: 600,\n        mass: 3,\n        useNativeDriver: position.__isNative,\n      }).start(onCompleteAnimation);\n    } else {\n      Animated.timing(position, {\n        toValue,\n        duration,\n        easing: EaseInOut,\n        useNativeDriver: position.__isNative,\n      }).start(onCompleteAnimation);\n    }\n  }\n\n  render() {\n    let floatingHeader = null;\n    const headerMode = this._getHeaderMode();\n    if (headerMode === 'float') {\n      floatingHeader = this._renderHeader(\n        this.props.transitionProps.scene,\n        headerMode\n      );\n    }\n    const {\n      transitionProps: { navigation, position, layout, scene, scenes },\n      mode,\n    } = this.props;\n    const { index } = navigation.state;\n    const isVertical = mode === 'modal';\n    const { options } = this._getScreenDetails(scene);\n    const gestureDirectionInverted = options.gestureDirection === 'inverted';\n\n    const gesturesEnabled =\n      typeof options.gesturesEnabled === 'boolean'\n        ? options.gesturesEnabled\n        : Platform.OS === 'ios';\n\n    const responder = !gesturesEnabled\n      ? null\n      : PanResponder.create({\n          onPanResponderTerminate: () => {\n            this._isResponding = false;\n            this._reset(index, 0);\n          },\n          onPanResponderGrant: () => {\n            position.stopAnimation(value => {\n              this._isResponding = true;\n              this._gestureStartValue = value;\n            });\n          },\n          onMoveShouldSetPanResponder: (event, gesture) => {\n            if (index !== scene.index) {\n              return false;\n            }\n            const immediateIndex =\n              this._immediateIndex == null ? index : this._immediateIndex;\n            const currentDragDistance = gesture[isVertical ? 'dy' : 'dx'];\n            const currentDragPosition =\n              event.nativeEvent[isVertical ? 'pageY' : 'pageX'];\n            const axisLength = isVertical\n              ? layout.height.__getValue()\n              : layout.width.__getValue();\n            const axisHasBeenMeasured = !!axisLength;\n\n            // Measure the distance from the touch to the edge of the screen\n            const screenEdgeDistance = gestureDirectionInverted\n              ? axisLength - (currentDragPosition - currentDragDistance)\n              : currentDragPosition - currentDragDistance;\n            // Compare to the gesture distance relavant to card or modal\n            const {\n              gestureResponseDistance: userGestureResponseDistance = {},\n            } = this._getScreenDetails(scene).options;\n            const gestureResponseDistance = isVertical\n              ? userGestureResponseDistance.vertical ||\n                GESTURE_RESPONSE_DISTANCE_VERTICAL\n              : userGestureResponseDistance.horizontal ||\n                GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n            // GESTURE_RESPONSE_DISTANCE is about 25 or 30. Or 135 for modals\n            if (screenEdgeDistance > gestureResponseDistance) {\n              // Reject touches that started in the middle of the screen\n              return false;\n            }\n\n            const hasDraggedEnough =\n              Math.abs(currentDragDistance) > RESPOND_THRESHOLD;\n\n            const isOnFirstCard = immediateIndex === 0;\n            const shouldSetResponder =\n              hasDraggedEnough && axisHasBeenMeasured && !isOnFirstCard;\n            return shouldSetResponder;\n          },\n          onPanResponderMove: (event, gesture) => {\n            // Handle the moving touches for our granted responder\n            const startValue = this._gestureStartValue;\n            const axis = isVertical ? 'dy' : 'dx';\n            const axisDistance = isVertical\n              ? layout.height.__getValue()\n              : layout.width.__getValue();\n            const currentValue =\n              (I18nManager.isRTL && axis === 'dx') !== gestureDirectionInverted\n                ? startValue + gesture[axis] / axisDistance\n                : startValue - gesture[axis] / axisDistance;\n            const value = clamp(index - 1, currentValue, index);\n            position.setValue(value);\n          },\n          onPanResponderTerminationRequest: () =>\n            // Returning false will prevent other views from becoming responder while\n            // the navigation view is the responder (mid-gesture)\n            false,\n          onPanResponderRelease: (event, gesture) => {\n            if (!this._isResponding) {\n              return;\n            }\n            this._isResponding = false;\n\n            const immediateIndex =\n              this._immediateIndex == null ? index : this._immediateIndex;\n\n            // Calculate animate duration according to gesture speed and moved distance\n            const axisDistance = isVertical\n              ? layout.height.__getValue()\n              : layout.width.__getValue();\n            const movementDirection = gestureDirectionInverted ? -1 : 1;\n            const movedDistance =\n              movementDirection * gesture[isVertical ? 'dy' : 'dx'];\n            const gestureVelocity =\n              movementDirection * gesture[isVertical ? 'vy' : 'vx'];\n            const defaultVelocity = axisDistance / ANIMATION_DURATION;\n            const velocity = Math.max(\n              Math.abs(gestureVelocity),\n              defaultVelocity\n            );\n            const resetDuration = gestureDirectionInverted\n              ? (axisDistance - movedDistance) / velocity\n              : movedDistance / velocity;\n            const goBackDuration = gestureDirectionInverted\n              ? movedDistance / velocity\n              : (axisDistance - movedDistance) / velocity;\n\n            // To asyncronously get the current animated value, we need to run stopAnimation:\n            position.stopAnimation(value => {\n              // If the speed of the gesture release is significant, use that as the indication\n              // of intent\n              if (gestureVelocity < -0.5) {\n                this._reset(immediateIndex, resetDuration);\n                return;\n              }\n              if (gestureVelocity > 0.5) {\n                this._goBack(immediateIndex, goBackDuration);\n                return;\n              }\n\n              // Then filter based on the distance the screen was moved. Over a third of the way swiped,\n              // and the back will happen.\n              if (value <= index - POSITION_THRESHOLD) {\n                this._goBack(immediateIndex, goBackDuration);\n              } else {\n                this._reset(immediateIndex, resetDuration);\n              }\n            });\n          },\n        });\n\n    const handlers = gesturesEnabled ? responder.panHandlers : {};\n    const containerStyle = [\n      styles.container,\n      this._getTransitionConfig().containerStyle,\n    ];\n\n    return (\n      <View {...handlers} style={containerStyle}>\n        <View style={styles.scenes}>\n          {scenes.map(s => this._renderCard(s))}\n        </View>\n        {floatingHeader}\n      </View>\n    );\n  }\n\n  _getHeaderMode() {\n    if (this.props.headerMode) {\n      return this.props.headerMode;\n    }\n    if (Platform.OS === 'android' || this.props.mode === 'modal') {\n      return 'screen';\n    }\n    return 'float';\n  }\n\n  _getHeaderTransitionPreset() {\n    // On Android or with header mode screen, we always just use in-place,\n    // we ignore the option entirely (at least until we have other presets)\n    if (Platform.OS === 'android' || this._getHeaderMode() === 'screen') {\n      return 'fade-in-place';\n    }\n\n    // TODO: validations: 'fade-in-place' or 'uikit' are valid\n    if (this.props.headerTransitionPreset) {\n      return this.props.headerTransitionPreset;\n    } else {\n      return 'fade-in-place';\n    }\n  }\n\n  _renderInnerScene(SceneComponent, scene) {\n    const { navigation } = this._getScreenDetails(scene);\n    const { screenProps } = this.props;\n    const headerMode = this._getHeaderMode();\n    if (headerMode === 'screen') {\n      return (\n        <View style={styles.container}>\n          <View style={{ flex: 1 }}>\n            <SceneView\n              screenProps={screenProps}\n              navigation={navigation}\n              component={SceneComponent}\n            />\n          </View>\n          {this._renderHeader(scene, headerMode)}\n        </View>\n      );\n    }\n    return (\n      <SceneView\n        screenProps={this.props.screenProps}\n        navigation={navigation}\n        component={SceneComponent}\n      />\n    );\n  }\n\n  _getTransitionConfig = () => {\n    const isModal = this.props.mode === 'modal';\n\n    return TransitionConfigs.getTransitionConfig(\n      this.props.transitionConfig,\n      this.props.transitionProps,\n      this.props.prevTransitionProps,\n      isModal\n    );\n  };\n\n  _renderCard = scene => {\n    const { screenInterpolator } = this._getTransitionConfig();\n    const style =\n      screenInterpolator &&\n      screenInterpolator({ ...this.props.transitionProps, scene });\n\n    const SceneComponent = this.props.router.getComponentForRouteName(\n      scene.route.routeName\n    );\n\n    const { transitionProps, ...props } = this.props;\n\n    return (\n      <Card\n        {...props}\n        {...transitionProps}\n        key={`card_${scene.key}`}\n        style={[style, this.props.cardStyle]}\n        scene={scene}\n      >\n        {this._renderInnerScene(SceneComponent, scene)}\n      </Card>\n    );\n  };\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    // Header is physically rendered after scenes so that Header won't be\n    // covered by the shadows of the scenes.\n    // That said, we'd have use `flexDirection: 'column-reverse'` to move\n    // Header above the scenes.\n    flexDirection: 'column-reverse',\n  },\n  scenes: {\n    flex: 1,\n  },\n});\n\nexport default CardStack;\n"]},"metadata":{},"sourceType":"module"}