{"ast":null,"code":"import Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport getSceneIndicesForInterpolationInputRange from \"../../utils/getSceneIndicesForInterpolationInputRange\";\n\nvar crossFadeInterpolation = function crossFadeInterpolation(first, index, last) {\n  return {\n    inputRange: [first, index - 0.9, index - 0.2, index, last],\n    outputRange: [0, 0, 0.3, 1, 0]\n  };\n};\n\nfunction forLeft(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(first, index, last))\n  };\n}\n\nfunction forCenter(props) {\n  var position = props.position,\n      scene = props.scene;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(first, index, last))\n  };\n}\n\nfunction forRight(props) {\n  var position = props.position,\n      scene = props.scene;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(first, index, last))\n  };\n}\n\nfunction forLeftButton(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  return {\n    opacity: position.interpolate({\n      inputRange: [first, first + Math.abs(index - first) / 2, index, last - Math.abs(last - index) / 2, last],\n      outputRange: [0, 0.5, 1, 0.5, 0]\n    })\n  };\n}\n\nvar LEFT_LABEL_OFFSET = Dimensions.get('window').width / 2 - 70 - 25;\n\nfunction forLeftLabel(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  var offset = LEFT_LABEL_OFFSET;\n  return {\n    opacity: position.interpolate({\n      inputRange: [first, index - 0.35, index, index + 0.5, last],\n      outputRange: [0, 0, 1, 0.5, 0]\n    }),\n    transform: [{\n      translateX: position.interpolate({\n        inputRange: [first, index, last],\n        outputRange: I18nManager.isRTL ? [-offset, 0, offset] : [offset, 0, -offset * 1.5]\n      })\n    }]\n  };\n}\n\nvar TITLE_OFFSET_IOS = Dimensions.get('window').width / 2 - 70 + 25;\n\nfunction forCenterFromLeft(props) {\n  var position = props.position,\n      scene = props.scene;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  var inputRange = [first, index - 0.5, index, index + 0.5, last];\n  var offset = TITLE_OFFSET_IOS;\n  return {\n    opacity: position.interpolate({\n      inputRange: [first, index - 0.5, index, index + 0.7, last],\n      outputRange: [0, 0, 1, 0, 0]\n    }),\n    transform: [{\n      translateX: position.interpolate({\n        inputRange: [first, index, last],\n        outputRange: I18nManager.isRTL ? [-offset, 0, offset] : [offset, 0, -offset]\n      })\n    }]\n  };\n}\n\nexport default {\n  forLeft: forLeft,\n  forLeftButton: forLeftButton,\n  forLeftLabel: forLeftLabel,\n  forCenterFromLeft: forCenterFromLeft,\n  forCenter: forCenter,\n  forRight: forRight\n};","map":{"version":3,"sources":["/Users/felipe/projects/test-react/node_modules/react-navigation/src/views/Header/HeaderStyleInterpolator.js"],"names":["getSceneIndicesForInterpolationInputRange","crossFadeInterpolation","first","index","last","inputRange","outputRange","forLeft","props","position","scene","scenes","interpolate","opacity","forCenter","forRight","forLeftButton","Math","abs","LEFT_LABEL_OFFSET","Dimensions","get","width","forLeftLabel","offset","transform","translateX","I18nManager","isRTL","TITLE_OFFSET_IOS","forCenterFromLeft"],"mappings":"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","sourcesContent":["import { Dimensions, I18nManager } from 'react-native';\nimport getSceneIndicesForInterpolationInputRange from '../../utils/getSceneIndicesForInterpolationInputRange';\n\nconst crossFadeInterpolation = (first, index, last) => ({\n  inputRange: [first, index - 0.9, index - 0.2, index, last],\n  outputRange: [0, 0, 0.3, 1, 0],\n});\n\n/**\n * Utility that builds the style for the navigation header.\n *\n * +-------------+-------------+-------------+\n * |             |             |             |\n * |    Left     |   Title     |   Right     |\n * |  Component  |  Component  | Component   |\n * |             |             |             |\n * +-------------+-------------+-------------+\n */\n\nfunction forLeft(props) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(first, index, last)),\n  };\n}\n\nfunction forCenter(props) {\n  const { position, scene } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(first, index, last)),\n  };\n}\n\nfunction forRight(props) {\n  const { position, scene } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(first, index, last)),\n  };\n}\n\n/**\n * iOS UINavigationController style interpolators\n */\n\nfunction forLeftButton(props) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  return {\n    opacity: position.interpolate({\n      inputRange: [\n        first,\n        first + Math.abs(index - first) / 2,\n        index,\n        last - Math.abs(last - index) / 2,\n        last,\n      ],\n      outputRange: [0, 0.5, 1, 0.5, 0],\n    }),\n  };\n}\n\n/* \n * NOTE: this offset calculation is a an approximation that gives us\n * decent results in many cases, but it is ultimately a poor substitute\n * for text measurement. See the comment on title for more information.\n * \n * - 70 is the width of the left button area.\n * - 25 is the width of the left button icon (to account for label offset)\n */\nconst LEFT_LABEL_OFFSET = Dimensions.get('window').width / 2 - 70 - 25;\nfunction forLeftLabel(props) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  const offset = LEFT_LABEL_OFFSET;\n\n  return {\n    // For now we fade out the label before fading in the title, so the\n    // differences between the label and title position can be hopefully not so\n    // noticable to the user\n    opacity: position.interpolate({\n      inputRange: [first, index - 0.35, index, index + 0.5, last],\n      outputRange: [0, 0, 1, 0.5, 0],\n    }),\n    transform: [\n      {\n        translateX: position.interpolate({\n          inputRange: [first, index, last],\n          outputRange: I18nManager.isRTL\n            ? [-offset, 0, offset]\n            : [offset, 0, -offset * 1.5],\n        }),\n      },\n    ],\n  };\n}\n\n/* \n * NOTE: this offset calculation is a an approximation that gives us\n * decent results in many cases, but it is ultimately a poor substitute\n * for text measurement. We want the back button label to transition\n * smoothly into the title text and to do this we need to understand\n * where the title is positioned within the title container (since it is\n * centered).\n * \n * - 70 is the width of the left button area.\n * - 25 is the width of the left button icon (to account for label offset)\n */\nconst TITLE_OFFSET_IOS = Dimensions.get('window').width / 2 - 70 + 25;\nfunction forCenterFromLeft(props) {\n  const { position, scene } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n  const inputRange = [first, index - 0.5, index, index + 0.5, last];\n  const offset = TITLE_OFFSET_IOS;\n\n  return {\n    opacity: position.interpolate({\n      inputRange: [first, index - 0.5, index, index + 0.7, last],\n      outputRange: [0, 0, 1, 0, 0],\n    }),\n    transform: [\n      {\n        translateX: position.interpolate({\n          inputRange: [first, index, last],\n          outputRange: I18nManager.isRTL\n            ? [-offset, 0, offset]\n            : [offset, 0, -offset],\n        }),\n      },\n    ],\n  };\n}\n\nexport default {\n  forLeft,\n  forLeftButton,\n  forLeftLabel,\n  forCenterFromLeft,\n  forCenter,\n  forRight,\n};\n"]},"metadata":{},"sourceType":"module"}