{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport invariant from \"../utils/invariant\";\nimport getScreenForRouteName from \"./getScreenForRouteName\";\nimport createConfigGetter from \"./createConfigGetter\";\nimport NavigationActions from \"../NavigationActions\";\nimport validateRouteConfigMap from \"./validateRouteConfigMap\";\nimport getScreenConfigDeprecated from \"./getScreenConfigDeprecated\";\n\nfunction childrenUpdateWithoutSwitchingIndex(actionType) {\n  return [NavigationActions.SET_PARAMS, NavigationActions.COMPLETE_TRANSITION].includes(actionType);\n}\n\nexport default (function (routeConfigs) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  validateRouteConfigMap(routeConfigs);\n  var order = config.order || Object.keys(routeConfigs);\n  var paths = config.paths || {};\n  var initialRouteParams = config.initialRouteParams;\n  var initialRouteName = config.initialRouteName || order[0];\n  var initialRouteIndex = order.indexOf(initialRouteName);\n  var backBehavior = config.backBehavior || 'initialRoute';\n  var shouldBackNavigateToInitialRoute = backBehavior === 'initialRoute';\n  var tabRouters = {};\n  order.forEach(function (routeName) {\n    var routeConfig = routeConfigs[routeName];\n    paths[routeName] = typeof routeConfig.path === 'string' ? routeConfig.path : routeName;\n    tabRouters[routeName] = null;\n    var screen = getScreenForRouteName(routeConfigs, routeName);\n\n    if (screen.router) {\n      tabRouters[routeName] = screen.router;\n    }\n  });\n\n  if (initialRouteIndex === -1) {\n    throw new Error(\"Invalid initialRouteName '\" + initialRouteName + \"' for TabRouter. \" + (\"Should be one of \" + order.map(function (n) {\n      return \"\\\"\" + n + \"\\\"\";\n    }).join(', ')));\n  }\n\n  return {\n    getStateForAction: function getStateForAction(action, inputState) {\n      var state = inputState;\n\n      if (!state) {\n        var _routes = order.map(function (routeName) {\n          var params = routeName === initialRouteName ? initialRouteParams : undefined;\n          var tabRouter = tabRouters[routeName];\n\n          if (tabRouter) {\n            var childAction = NavigationActions.init();\n            return _objectSpread(_objectSpread({}, tabRouter.getStateForAction(childAction)), {}, {\n              key: routeName,\n              routeName: routeName,\n              params: params\n            });\n          }\n\n          return {\n            key: routeName,\n            routeName: routeName,\n            params: params\n          };\n        });\n\n        state = {\n          routes: _routes,\n          index: initialRouteIndex,\n          isTransitioning: false\n        };\n      }\n\n      if (action.type === NavigationActions.INIT) {\n        var params = action.params;\n\n        if (params) {\n          state.routes = state.routes.map(function (route) {\n            return _objectSpread(_objectSpread({}, route), {}, {\n              params: _objectSpread(_objectSpread(_objectSpread({}, route.params), params), route.routeName === initialRouteName ? initialRouteParams : null)\n            });\n          });\n        }\n      }\n\n      var activeTabLastState = state.routes[state.index];\n      var activeTabRouter = tabRouters[order[state.index]];\n\n      if (activeTabRouter) {\n        var activeTabState = activeTabRouter.getStateForAction(action, activeTabLastState);\n\n        if (!activeTabState && inputState) {\n          return null;\n        }\n\n        if (activeTabState && activeTabState !== activeTabLastState) {\n          var _routes2 = _toConsumableArray(state.routes);\n\n          _routes2[state.index] = activeTabState;\n          return _objectSpread(_objectSpread({}, state), {}, {\n            routes: _routes2\n          });\n        }\n      }\n\n      var activeTabIndex = state.index;\n      var isBackEligible = action.key == null || action.key === activeTabLastState.key;\n\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && shouldBackNavigateToInitialRoute) {\n          activeTabIndex = initialRouteIndex;\n        } else {\n          return state;\n        }\n      }\n\n      var didNavigate = false;\n\n      if (action.type === NavigationActions.NAVIGATE) {\n        var navigateAction = action;\n        didNavigate = !!order.find(function (tabId, i) {\n          if (tabId === navigateAction.routeName) {\n            activeTabIndex = i;\n            return true;\n          }\n\n          return false;\n        });\n\n        if (didNavigate) {\n          var childState = state.routes[activeTabIndex];\n          var newChildState;\n          var tabRouter = tabRouters[action.routeName];\n\n          if (action.action) {\n            newChildState = tabRouter ? tabRouter.getStateForAction(action.action, childState) : null;\n          } else if (!tabRouter && action.params) {\n            newChildState = _objectSpread(_objectSpread({}, childState), {}, {\n              params: _objectSpread(_objectSpread({}, childState.params || {}), action.params)\n            });\n          }\n\n          if (newChildState && newChildState !== childState) {\n            var _routes3 = _toConsumableArray(state.routes);\n\n            _routes3[activeTabIndex] = newChildState;\n            return _objectSpread(_objectSpread({}, state), {}, {\n              routes: _routes3,\n              index: activeTabIndex\n            });\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        var key = action.key;\n        var lastRoute = state.routes.find(function (route) {\n          return route.key === key;\n        });\n\n        if (lastRoute) {\n          var _params = _objectSpread(_objectSpread({}, lastRoute.params), action.params);\n\n          var _routes4 = _toConsumableArray(state.routes);\n\n          _routes4[state.routes.indexOf(lastRoute)] = _objectSpread(_objectSpread({}, lastRoute), {}, {\n            params: _params\n          });\n          return _objectSpread(_objectSpread({}, state), {}, {\n            routes: _routes4\n          });\n        }\n      }\n\n      if (activeTabIndex !== state.index) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          index: activeTabIndex\n        });\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return null;\n      }\n\n      var index = state.index;\n      var routes = state.routes;\n      order.find(function (tabId, i) {\n        var tabRouter = tabRouters[tabId];\n\n        if (i === index) {\n          return false;\n        }\n\n        var tabState = routes[i];\n\n        if (tabRouter) {\n          tabState = tabRouter.getStateForAction(action, tabState);\n        }\n\n        if (!tabState) {\n          index = i;\n          return true;\n        }\n\n        if (tabState !== routes[i]) {\n          routes = _toConsumableArray(routes);\n          routes[i] = tabState;\n          index = i;\n          return true;\n        }\n\n        return false;\n      });\n\n      if (childrenUpdateWithoutSwitchingIndex(action.type)) {\n        index = state.index;\n      }\n\n      if (index !== state.index || routes !== state.routes) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          index: index,\n          routes: routes\n        });\n      }\n\n      return state;\n    },\n    getComponentForState: function getComponentForState(state) {\n      var routeName = state.routes[state.index].routeName;\n      invariant(routeName, \"There is no route defined for index \" + state.index + \". Check that\\n        that you passed in a navigation state with a valid tab/screen index.\");\n      var childRouter = tabRouters[routeName];\n\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getComponentForRouteName: function getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getPathAndParamsForState: function getPathAndParamsForState(state) {\n      var route = state.routes[state.index];\n      var routeName = order[state.index];\n      var subPath = paths[routeName];\n      var screen = getScreenForRouteName(routeConfigs, routeName);\n      var path = subPath;\n      var params = route.params;\n\n      if (screen && screen.router) {\n        var stateRoute = route;\n        var child = screen.router.getPathAndParamsForState(stateRoute);\n        path = subPath ? subPath + \"/\" + child.path : child.path;\n        params = child.params ? _objectSpread(_objectSpread({}, params), child.params) : params;\n      }\n\n      return {\n        path: path,\n        params: params\n      };\n    },\n    getActionForPathAndParams: function getActionForPathAndParams(path, params) {\n      return order.map(function (tabId) {\n        var parts = path.split('/');\n        var pathToTest = paths[tabId];\n\n        if (parts[0] === pathToTest) {\n          var tabRouter = tabRouters[tabId];\n          var action = NavigationActions.navigate({\n            routeName: tabId\n          });\n\n          if (tabRouter && tabRouter.getActionForPathAndParams) {\n            action.action = tabRouter.getActionForPathAndParams(parts.slice(1).join('/'), params);\n          } else if (params) {\n            action.params = params;\n          }\n\n          return action;\n        }\n\n        return null;\n      }).find(function (action) {\n        return !!action;\n      }) || order.map(function (tabId) {\n        var tabRouter = tabRouters[tabId];\n        return tabRouter && tabRouter.getActionForPathAndParams(path, params);\n      }).find(function (action) {\n        return !!action;\n      }) || null;\n    },\n    getScreenOptions: createConfigGetter(routeConfigs, config.navigationOptions),\n    getScreenConfig: getScreenConfigDeprecated\n  };\n});","map":{"version":3,"sources":["/Users/felipe/projects/lucy-farm/AwesomeProject/node_modules/react-navigation/src/routers/TabRouter.js"],"names":["invariant","getScreenForRouteName","createConfigGetter","NavigationActions","validateRouteConfigMap","getScreenConfigDeprecated","childrenUpdateWithoutSwitchingIndex","actionType","SET_PARAMS","COMPLETE_TRANSITION","includes","routeConfigs","config","order","Object","keys","paths","initialRouteParams","initialRouteName","initialRouteIndex","indexOf","backBehavior","shouldBackNavigateToInitialRoute","tabRouters","forEach","routeName","routeConfig","path","screen","router","Error","map","n","join","getStateForAction","action","inputState","state","routes","params","undefined","tabRouter","childAction","init","key","index","isTransitioning","type","INIT","route","activeTabLastState","activeTabRouter","activeTabState","activeTabIndex","isBackEligible","BACK","didNavigate","NAVIGATE","navigateAction","find","tabId","i","childState","newChildState","lastRoute","tabState","getComponentForState","childRouter","getComponentForRouteName","getPathAndParamsForState","subPath","stateRoute","child","getActionForPathAndParams","parts","split","pathToTest","navigate","slice","getScreenOptions","navigationOptions","getScreenConfig"],"mappings":"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","sourcesContent":["import invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\n\nimport NavigationActions from '../NavigationActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport getScreenConfigDeprecated from './getScreenConfigDeprecated';\n\nfunction childrenUpdateWithoutSwitchingIndex(actionType) {\n  return [\n    NavigationActions.SET_PARAMS,\n    NavigationActions.COMPLETE_TRANSITION,\n  ].includes(actionType);\n}\n\nexport default (routeConfigs, config = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const order = config.order || Object.keys(routeConfigs);\n  const paths = config.paths || {};\n  const initialRouteParams = config.initialRouteParams;\n  const initialRouteName = config.initialRouteName || order[0];\n  const initialRouteIndex = order.indexOf(initialRouteName);\n  const backBehavior = config.backBehavior || 'initialRoute';\n  const shouldBackNavigateToInitialRoute = backBehavior === 'initialRoute';\n  const tabRouters = {};\n  order.forEach(routeName => {\n    const routeConfig = routeConfigs[routeName];\n    paths[routeName] =\n      typeof routeConfig.path === 'string' ? routeConfig.path : routeName;\n    tabRouters[routeName] = null;\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen.router) {\n      tabRouters[routeName] = screen.router;\n    }\n  });\n  if (initialRouteIndex === -1) {\n    throw new Error(\n      `Invalid initialRouteName '${initialRouteName}' for TabRouter. ` +\n        `Should be one of ${order.map(n => `\"${n}\"`).join(', ')}`\n    );\n  }\n  return {\n    getStateForAction(action, inputState) {\n      // Establish a default state\n      let state = inputState;\n      if (!state) {\n        const routes = order.map(routeName => {\n          const params =\n            routeName === initialRouteName ? initialRouteParams : undefined;\n          const tabRouter = tabRouters[routeName];\n          if (tabRouter) {\n            const childAction = NavigationActions.init();\n            return {\n              ...tabRouter.getStateForAction(childAction),\n              key: routeName,\n              routeName,\n              params,\n            };\n          }\n          return {\n            key: routeName,\n            routeName,\n            params,\n          };\n        });\n        state = {\n          routes,\n          index: initialRouteIndex,\n          isTransitioning: false,\n        };\n        // console.log(`${order.join('-')}: Initial state`, {state});\n      }\n\n      if (action.type === NavigationActions.INIT) {\n        // Merge any params from the action into all the child routes\n        const { params } = action;\n        if (params) {\n          state.routes = state.routes.map(route => ({\n            ...route,\n            params: {\n              ...route.params,\n              ...params,\n              ...(route.routeName === initialRouteName\n                ? initialRouteParams\n                : null),\n            },\n          }));\n        }\n      }\n\n      // Let the current tab handle it\n      const activeTabLastState = state.routes[state.index];\n      const activeTabRouter = tabRouters[order[state.index]];\n      if (activeTabRouter) {\n        const activeTabState = activeTabRouter.getStateForAction(\n          action,\n          activeTabLastState\n        );\n        if (!activeTabState && inputState) {\n          return null;\n        }\n        if (activeTabState && activeTabState !== activeTabLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeTabState;\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n\n      // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner tabs to change first\n      let activeTabIndex = state.index;\n      const isBackEligible =\n        action.key == null || action.key === activeTabLastState.key;\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && shouldBackNavigateToInitialRoute) {\n          activeTabIndex = initialRouteIndex;\n        } else {\n          return state;\n        }\n      }\n      let didNavigate = false;\n      if (action.type === NavigationActions.NAVIGATE) {\n        const navigateAction = action;\n        didNavigate = !!order.find((tabId, i) => {\n          if (tabId === navigateAction.routeName) {\n            activeTabIndex = i;\n            return true;\n          }\n          return false;\n        });\n        if (didNavigate) {\n          const childState = state.routes[activeTabIndex];\n          let newChildState;\n\n          const tabRouter = tabRouters[action.routeName];\n\n          if (action.action) {\n            newChildState = tabRouter\n              ? tabRouter.getStateForAction(action.action, childState)\n              : null;\n          } else if (!tabRouter && action.params) {\n            newChildState = {\n              ...childState,\n              params: {\n                ...(childState.params || {}),\n                ...action.params,\n              },\n            };\n          }\n\n          if (newChildState && newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeTabIndex] = newChildState;\n            return {\n              ...state,\n              routes,\n              index: activeTabIndex,\n            };\n          }\n        }\n      }\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n      if (activeTabIndex !== state.index) {\n        return {\n          ...state,\n          index: activeTabIndex,\n        };\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return null;\n      }\n\n      // Let other tabs handle it and switch to the first tab that returns a new state\n      let index = state.index;\n      let routes = state.routes;\n      order.find((tabId, i) => {\n        const tabRouter = tabRouters[tabId];\n        if (i === index) {\n          return false;\n        }\n        let tabState = routes[i];\n        if (tabRouter) {\n          // console.log(`${order.join('-')}: Processing child router:`, {action, tabState});\n          tabState = tabRouter.getStateForAction(action, tabState);\n        }\n        if (!tabState) {\n          index = i;\n          return true;\n        }\n        if (tabState !== routes[i]) {\n          routes = [...routes];\n          routes[i] = tabState;\n          index = i;\n          return true;\n        }\n        return false;\n      });\n      // console.log(`${order.join('-')}: Processed other tabs:`, {lastIndex: state.index, index});\n\n      // Nested routers can be updated after switching tabs with actions such as SET_PARAMS\n      // and COMPLETE_TRANSITION.\n      // NOTE: This may be problematic with custom routers because we whitelist the actions\n      // that can be handled by child routers without automatically changing index.\n      if (childrenUpdateWithoutSwitchingIndex(action.type)) {\n        index = state.index;\n      }\n\n      if (index !== state.index || routes !== state.routes) {\n        return {\n          ...state,\n          index,\n          routes,\n        };\n      }\n      return state;\n    },\n\n    getComponentForState(state) {\n      const routeName = state.routes[state.index].routeName;\n      invariant(\n        routeName,\n        `There is no route defined for index ${state.index}. Check that\n        that you passed in a navigation state with a valid tab/screen index.`\n      );\n      const childRouter = tabRouters[routeName];\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      const routeName = order[state.index];\n      const subPath = paths[routeName];\n      const screen = getScreenForRouteName(routeConfigs, routeName);\n      let path = subPath;\n      let params = route.params;\n      if (screen && screen.router) {\n        const stateRoute = route;\n        // If it has a router it's a navigator.\n        // If it doesn't have router it's an ordinary React component.\n        const child = screen.router.getPathAndParamsForState(stateRoute);\n        path = subPath ? `${subPath}/${child.path}` : child.path;\n        params = child.params ? { ...params, ...child.params } : params;\n      }\n      return {\n        path,\n        params,\n      };\n    },\n\n    /**\n     * Gets an optional action, based on a relative path and query params.\n     *\n     * This will return null if there is no action matched\n     */\n    getActionForPathAndParams(path, params) {\n      return (\n        order\n          .map(tabId => {\n            const parts = path.split('/');\n            const pathToTest = paths[tabId];\n            if (parts[0] === pathToTest) {\n              const tabRouter = tabRouters[tabId];\n              const action = NavigationActions.navigate({\n                routeName: tabId,\n              });\n              if (tabRouter && tabRouter.getActionForPathAndParams) {\n                action.action = tabRouter.getActionForPathAndParams(\n                  parts.slice(1).join('/'),\n                  params\n                );\n              } else if (params) {\n                action.params = params;\n              }\n              return action;\n            }\n            return null;\n          })\n          .find(action => !!action) ||\n        order\n          .map(tabId => {\n            const tabRouter = tabRouters[tabId];\n            return (\n              tabRouter && tabRouter.getActionForPathAndParams(path, params)\n            );\n          })\n          .find(action => !!action) ||\n        null\n      );\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      config.navigationOptions\n    ),\n\n    getScreenConfig: getScreenConfigDeprecated,\n  };\n};\n"]},"metadata":{},"sourceType":"module"}