{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport invariant from \"../utils/invariant\";\nimport shallowEqual from \"../utils/shallowEqual\";\nvar SCENE_KEY_PREFIX = 'scene_';\n\nfunction compareKey(one, two) {\n  var delta = one.length - two.length;\n\n  if (delta > 0) {\n    return 1;\n  }\n\n  if (delta < 0) {\n    return -1;\n  }\n\n  return one > two ? 1 : -1;\n}\n\nfunction compareScenes(one, two) {\n  if (one.index > two.index) {\n    return 1;\n  }\n\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n\nfunction areScenesShallowEqual(one, two) {\n  return one.key === two.key && one.index === two.index && one.isStale === two.isStale && one.isActive === two.isActive && areRoutesShallowEqual(one.route, two.route);\n}\n\nfunction areRoutesShallowEqual(one, two) {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(scenes, nextState, prevState) {\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  var prevScenes = new Map();\n  var freshScenes = new Map();\n  var staleScenes = new Map();\n  scenes.forEach(function (scene) {\n    var key = scene.key;\n\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n\n    prevScenes.set(key, scene);\n  });\n  var nextKeys = new Set();\n  nextState.routes.forEach(function (route, index) {\n    var key = SCENE_KEY_PREFIX + route.key;\n    var scene = {\n      index: index,\n      isActive: false,\n      isStale: false,\n      key: key,\n      route: route\n    };\n    invariant(!nextKeys.has(key), \"navigation.state.routes[\" + index + \"].key \\\"\" + key + \"\\\" conflicts with \" + 'another route!');\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      staleScenes.delete(key);\n    }\n\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    prevState.routes.forEach(function (route, index) {\n      var key = SCENE_KEY_PREFIX + route.key;\n\n      if (freshScenes.has(key)) {\n        return;\n      }\n\n      staleScenes.set(key, {\n        index: index,\n        isActive: false,\n        isStale: true,\n        key: key,\n        route: route\n      });\n    });\n  }\n\n  var nextScenes = [];\n\n  var mergeScene = function mergeScene(nextScene) {\n    var key = nextScene.key;\n    var prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n  nextScenes.sort(compareScenes);\n  var activeScenesCount = 0;\n  nextScenes.forEach(function (scene, ii) {\n    var isActive = !scene.isStale && scene.index === nextState.index;\n\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = _objectSpread(_objectSpread({}, scene), {}, {\n        isActive: isActive\n      });\n    }\n\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n  invariant(activeScenesCount === 1, 'there should always be only one scene active, not %s.', activeScenesCount);\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (nextScenes.some(function (scene, index) {\n    return !areScenesShallowEqual(scenes[index], scene);\n  })) {\n    return nextScenes;\n  }\n\n  return scenes;\n}","map":{"version":3,"sources":["/Users/felipe/projects/test-react/node_modules/react-navigation/src/views/ScenesReducer.js"],"names":["invariant","shallowEqual","SCENE_KEY_PREFIX","compareKey","one","two","delta","length","compareScenes","index","key","areScenesShallowEqual","isStale","isActive","areRoutesShallowEqual","route","ScenesReducer","scenes","nextState","prevState","prevScenes","Map","freshScenes","staleScenes","forEach","scene","set","nextKeys","Set","routes","has","add","delete","nextScenes","mergeScene","nextScene","prevScene","get","push","sort","activeScenesCount","ii","some"],"mappings":"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","sourcesContent":["import invariant from '../utils/invariant';\nimport shallowEqual from '../utils/shallowEqual';\n\nconst SCENE_KEY_PREFIX = 'scene_';\n\n/**\n * Helper function to compare route keys (e.g. \"9\", \"11\").\n */\nfunction compareKey(one, two) {\n  const delta = one.length - two.length;\n  if (delta > 0) {\n    return 1;\n  }\n  if (delta < 0) {\n    return -1;\n  }\n  return one > two ? 1 : -1;\n}\n\n/**\n * Helper function to sort scenes based on their index and view key.\n */\nfunction compareScenes(one, two) {\n  if (one.index > two.index) {\n    return 1;\n  }\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areScenesShallowEqual(one, two) {\n  return (\n    one.key === two.key &&\n    one.index === two.index &&\n    one.isStale === two.isStale &&\n    one.isActive === two.isActive &&\n    areRoutesShallowEqual(one.route, two.route)\n  );\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areRoutesShallowEqual(one, two) {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(scenes, nextState, prevState) {\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  const prevScenes = new Map();\n  const freshScenes = new Map();\n  const staleScenes = new Map();\n\n  // Populate stale scenes from previous scenes marked as stale.\n  scenes.forEach(scene => {\n    const { key } = scene;\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n    prevScenes.set(key, scene);\n  });\n\n  const nextKeys = new Set();\n  nextState.routes.forEach((route, index) => {\n    const key = SCENE_KEY_PREFIX + route.key;\n    const scene = {\n      index,\n      isActive: false,\n      isStale: false,\n      key,\n      route,\n    };\n    invariant(\n      !nextKeys.has(key),\n      `navigation.state.routes[${index}].key \"${key}\" conflicts with ` +\n        'another route!'\n    );\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      // A previously `stale` scene is now part of the nextState, so we\n      // revive it by removing it from the stale scene map.\n      staleScenes.delete(key);\n    }\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    // Look at the previous routes and classify any removed scenes as `stale`.\n    prevState.routes.forEach((route, index) => {\n      const key = SCENE_KEY_PREFIX + route.key;\n      if (freshScenes.has(key)) {\n        return;\n      }\n      staleScenes.set(key, {\n        index,\n        isActive: false,\n        isStale: true,\n        key,\n        route,\n      });\n    });\n  }\n\n  const nextScenes = [];\n\n  const mergeScene = nextScene => {\n    const { key } = nextScene;\n    const prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      // Reuse `prevScene` as `scene` so view can avoid unnecessary re-render.\n      // This assumes that the scene's navigation state is immutable.\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n\n  nextScenes.sort(compareScenes);\n\n  let activeScenesCount = 0;\n  nextScenes.forEach((scene, ii) => {\n    const isActive = !scene.isStale && scene.index === nextState.index;\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = {\n        ...scene,\n        isActive,\n      };\n    }\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n\n  invariant(\n    activeScenesCount === 1,\n    'there should always be only one scene active, not %s.',\n    activeScenesCount\n  );\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (\n    nextScenes.some(\n      (scene, index) => !areScenesShallowEqual(scenes[index], scene)\n    )\n  ) {\n    return nextScenes;\n  }\n\n  // scenes haven't changed.\n  return scenes;\n}\n"]},"metadata":{},"sourceType":"module"}