{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport pathToRegexp from 'path-to-regexp';\nimport NavigationActions from \"../NavigationActions\";\nimport createConfigGetter from \"./createConfigGetter\";\nimport getScreenForRouteName from \"./getScreenForRouteName\";\nimport StateUtils from \"../StateUtils\";\nimport validateRouteConfigMap from \"./validateRouteConfigMap\";\nimport getScreenConfigDeprecated from \"./getScreenConfigDeprecated\";\nimport invariant from \"../utils/invariant\";\nimport { generateKey } from \"./KeyGenerator\";\n\nfunction isEmpty(obj) {\n  if (!obj) return true;\n\n  for (var key in obj) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction behavesLikePushAction(action) {\n  return action.type === NavigationActions.NAVIGATE || action.type === NavigationActions.PUSH;\n}\n\nexport default (function (routeConfigs) {\n  var stackConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  validateRouteConfigMap(routeConfigs);\n  var childRouters = {};\n  var routeNames = Object.keys(routeConfigs);\n  routeNames.forEach(function (routeName) {\n    var screen = getScreenForRouteName(routeConfigs, routeName);\n\n    if (screen && screen.router) {\n      childRouters[routeName] = screen.router;\n    } else {\n      childRouters[routeName] = null;\n    }\n  });\n  var initialRouteParams = stackConfig.initialRouteParams;\n  var initialRouteName = stackConfig.initialRouteName || routeNames[0];\n  var initialChildRouter = childRouters[initialRouteName];\n  var pathsByRouteNames = _objectSpread({}, stackConfig.paths) || {};\n  var paths = [];\n\n  function getInitialState(action) {\n    var route = {};\n    var childRouter = childRouters[action.routeName];\n\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      var childState = {};\n\n      if (childRouter !== null) {\n        var childAction = action.action || NavigationActions.init({\n          params: action.params\n        });\n        childState = childRouter.getStateForAction(childAction);\n      }\n\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [_objectSpread(_objectSpread({\n          params: action.params\n        }, childState), {}, {\n          key: action.key || generateKey(),\n          routeName: action.routeName\n        })]\n      };\n    }\n\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(NavigationActions.navigate({\n        routeName: initialRouteName,\n        params: initialRouteParams\n      }));\n    }\n\n    var params = (route.params || action.params || initialRouteParams) && _objectSpread(_objectSpread(_objectSpread({}, route.params || {}), action.params || {}), initialRouteParams || {});\n\n    var initialRouteKey = stackConfig.initialRouteKey;\n    route = _objectSpread(_objectSpread(_objectSpread({}, route), params ? {\n      params: params\n    } : {}), {}, {\n      routeName: initialRouteName,\n      key: action.key || initialRouteKey || generateKey()\n    });\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route]\n    };\n  }\n\n  routeNames.forEach(function (routeName) {\n    var pathPattern = pathsByRouteNames[routeName] || routeConfigs[routeName].path;\n    var matchExact = !!pathPattern && !childRouters[routeName];\n\n    if (pathPattern === undefined) {\n      pathPattern = routeName;\n    }\n\n    var keys = [];\n    var re, toPath, priority;\n\n    if (typeof pathPattern === 'string') {\n      re = pathToRegexp(pathPattern, keys);\n      toPath = pathToRegexp.compile(pathPattern);\n      priority = 0;\n    } else {\n      re = pathToRegexp('*', keys);\n\n      toPath = function toPath() {\n        return '';\n      };\n\n      matchExact = true;\n      priority = -1;\n    }\n\n    if (!matchExact) {\n      var wildcardRe = pathToRegexp(pathPattern + \"/*\", keys);\n      re = new RegExp(\"(?:\" + re.source + \")|(?:\" + wildcardRe.source + \")\");\n    }\n\n    pathsByRouteNames[routeName] = {\n      re: re,\n      keys: keys,\n      toPath: toPath,\n      priority: priority\n    };\n  });\n  paths = Object.entries(pathsByRouteNames);\n  paths.sort(function (a, b) {\n    return b[1].priority - a[1].priority;\n  });\n  return {\n    getComponentForState: function getComponentForState(state) {\n      var activeChildRoute = state.routes[state.index];\n      var routeName = activeChildRoute.routeName;\n\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getComponentForRouteName: function getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getStateForAction: function getStateForAction(action, state) {\n      if (!state) {\n        return getInitialState(action);\n      }\n\n      if (action.type !== NavigationActions.RESET || action.key !== null) {\n        var keyIndex = action.key ? StateUtils.indexOf(state, action.key) : -1;\n        var childIndex = keyIndex >= 0 ? keyIndex : state.index;\n        var childRoute = state.routes[childIndex];\n        invariant(childRoute, \"StateUtils erroneously thought index \" + childIndex + \" exists\");\n        var childRouter = childRouters[childRoute.routeName];\n\n        if (childRouter) {\n          var route = childRouter.getStateForAction(action, childRoute);\n\n          if (route === null) {\n            return state;\n          }\n\n          if (route && route !== childRoute) {\n            return StateUtils.replaceAt(state, childRoute.key, route);\n          }\n        }\n      }\n\n      if (behavesLikePushAction(action) && childRouters[action.routeName] !== undefined) {\n        var _childRouter = childRouters[action.routeName];\n\n        var _route;\n\n        invariant(action.type !== NavigationActions.PUSH || action.key == null, 'StackRouter does not support key on the push action');\n\n        if (action.key) {\n          var lastRouteIndex = state.routes.findIndex(function (r) {\n            return r.key === action.key;\n          });\n\n          if (lastRouteIndex !== -1) {\n            if (state.index === lastRouteIndex && !action.params) {\n              return state;\n            }\n\n            var routes = state.routes.slice(0, lastRouteIndex + 1);\n\n            if (action.params) {\n              var _route2 = state.routes.find(function (r) {\n                return r.key === action.key;\n              });\n\n              routes[lastRouteIndex] = _objectSpread(_objectSpread({}, _route2), {}, {\n                params: _objectSpread(_objectSpread({}, _route2.params), action.params)\n              });\n            }\n\n            return _objectSpread(_objectSpread({}, state), {}, {\n              isTransitioning: state.index !== lastRouteIndex ? action.immediate !== true : undefined,\n              index: lastRouteIndex,\n              routes: routes\n            });\n          }\n        }\n\n        if (_childRouter) {\n          var childAction = action.action || NavigationActions.init({\n            params: action.params\n          });\n          _route = _objectSpread(_objectSpread({\n            params: action.params\n          }, _childRouter.getStateForAction(childAction)), {}, {\n            routeName: action.routeName,\n            key: action.key || generateKey()\n          });\n        } else {\n          _route = {\n            params: action.params,\n            routeName: action.routeName,\n            key: action.key || generateKey()\n          };\n        }\n\n        return _objectSpread(_objectSpread({}, StateUtils.push(state, _route)), {}, {\n          isTransitioning: action.immediate !== true\n        });\n      } else if (action.type === NavigationActions.PUSH && childRouters[action.routeName] === undefined) {\n        return _objectSpread({}, state);\n      }\n\n      if (behavesLikePushAction(action)) {\n        var childRouterNames = Object.keys(childRouters);\n\n        for (var i = 0; i < childRouterNames.length; i++) {\n          var childRouterName = childRouterNames[i];\n          var _childRouter2 = childRouters[childRouterName];\n\n          if (_childRouter2) {\n            var initChildRoute = _childRouter2.getStateForAction(NavigationActions.init());\n\n            var navigatedChildRoute = _childRouter2.getStateForAction(action, initChildRoute);\n\n            var routeToPush = null;\n\n            if (navigatedChildRoute === null) {\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              routeToPush = navigatedChildRoute;\n            }\n\n            if (routeToPush) {\n              var _route3 = _objectSpread(_objectSpread({}, routeToPush), {}, {\n                routeName: childRouterName,\n                key: action.key || generateKey()\n              });\n\n              return StateUtils.push(state, _route3);\n            }\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.POP_TO_TOP) {\n        if (action.key && state.key !== action.key) {\n          return state;\n        }\n\n        if (state.index === 0) {\n          return _objectSpread({}, state);\n        } else {\n          return _objectSpread(_objectSpread({}, state), {}, {\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]]\n          });\n        }\n\n        return state;\n      }\n\n      if (action.type === NavigationActions.REPLACE) {\n        var routeIndex = state.routes.findIndex(function (r) {\n          return r.key === action.key;\n        });\n\n        if (routeIndex !== -1) {\n          var _childRouter3 = childRouters[action.routeName];\n          var childState = {};\n\n          if (_childRouter3) {\n            var _childAction = action.action || NavigationActions.init({\n              params: action.params\n            });\n\n            childState = _childRouter3.getStateForAction(_childAction);\n          }\n\n          var _routes = _toConsumableArray(state.routes);\n\n          _routes[routeIndex] = _objectSpread(_objectSpread({\n            params: action.params\n          }, childState), {}, {\n            routeName: action.routeName,\n            key: action.newKey || generateKey()\n          });\n          return _objectSpread(_objectSpread({}, state), {}, {\n            routes: _routes\n          });\n        }\n      }\n\n      if (action.type === NavigationActions.COMPLETE_TRANSITION && (action.key == null || action.key === state.key) && state.isTransitioning) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          isTransitioning: false\n        });\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        var key = action.key;\n        var lastRoute = state.routes.find(function (route) {\n          return route.key === key;\n        });\n\n        if (lastRoute) {\n          var params = _objectSpread(_objectSpread({}, lastRoute.params), action.params);\n\n          var _routes2 = _toConsumableArray(state.routes);\n\n          _routes2[state.routes.indexOf(lastRoute)] = _objectSpread(_objectSpread({}, lastRoute), {}, {\n            params: params\n          });\n          return _objectSpread(_objectSpread({}, state), {}, {\n            routes: _routes2\n          });\n        }\n      }\n\n      if (action.type === NavigationActions.RESET) {\n        if (action.key != null && action.key != state.key) {\n          return state;\n        }\n\n        var newStackActions = action.actions;\n        return _objectSpread(_objectSpread({}, state), {}, {\n          routes: newStackActions.map(function (newStackAction) {\n            var router = childRouters[newStackAction.routeName];\n            var childState = {};\n\n            if (router) {\n              var _childAction2 = newStackAction.action || NavigationActions.init({\n                params: newStackAction.params\n              });\n\n              childState = router.getStateForAction(_childAction2);\n            }\n\n            return _objectSpread(_objectSpread({\n              params: newStackAction.params\n            }, childState), {}, {\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || generateKey()\n            });\n          }),\n          index: action.index\n        });\n      }\n\n      if (action.type === NavigationActions.BACK || action.type === NavigationActions.POP) {\n        var _key = action.key,\n            n = action.n,\n            immediate = action.immediate;\n        var backRouteIndex = state.index;\n\n        if (action.type === NavigationActions.POP && n != null) {\n          backRouteIndex = Math.max(1, state.index - n + 1);\n        } else if (_key) {\n          var backRoute = state.routes.find(function (route) {\n            return route.key === _key;\n          });\n          backRouteIndex = state.routes.indexOf(backRoute);\n        }\n\n        if (backRouteIndex > 0) {\n          return _objectSpread(_objectSpread({}, state), {}, {\n            routes: state.routes.slice(0, backRouteIndex),\n            index: backRouteIndex - 1,\n            isTransitioning: immediate !== true\n          });\n        } else if (backRouteIndex === 0 && action.type === NavigationActions.POP) {\n          return _objectSpread({}, state);\n        }\n      }\n\n      return state;\n    },\n    getPathAndParamsForState: function getPathAndParamsForState(state) {\n      var route = state.routes[state.index];\n      var routeName = route.routeName;\n      var screen = getScreenForRouteName(routeConfigs, routeName);\n      var subPath = pathsByRouteNames[routeName].toPath(route.params);\n      var path = subPath;\n      var params = route.params;\n\n      if (screen && screen.router) {\n        var stateRoute = route;\n        var child = screen.router.getPathAndParamsForState(stateRoute);\n        path = subPath ? subPath + \"/\" + child.path : child.path;\n        params = child.params ? _objectSpread(_objectSpread({}, params), child.params) : params;\n      }\n\n      return {\n        path: path,\n        params: params\n      };\n    },\n    getActionForPathAndParams: function getActionForPathAndParams(pathToResolve, inputParams) {\n      if (!pathToResolve) {\n        return NavigationActions.navigate({\n          routeName: initialRouteName\n        });\n      }\n\n      var _pathToResolve$split = pathToResolve.split('?'),\n          _pathToResolve$split2 = _slicedToArray(_pathToResolve$split, 2),\n          pathNameToResolve = _pathToResolve$split2[0],\n          queryString = _pathToResolve$split2[1];\n\n      var matchedRouteName;\n      var pathMatch;\n      var pathMatchKeys;\n\n      for (var _iterator = _createForOfIteratorHelperLoose(paths), _step; !(_step = _iterator()).done;) {\n        var _ref = _step.value;\n\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        var routeName = _ref2[0];\n        var path = _ref2[1];\n        var re = path.re,\n            keys = path.keys;\n        pathMatch = re.exec(pathNameToResolve);\n\n        if (pathMatch && pathMatch.length) {\n          pathMatchKeys = keys;\n          matchedRouteName = routeName;\n          break;\n        }\n      }\n\n      if (!matchedRouteName) {\n        if (!pathToResolve) {\n          return NavigationActions.navigate({\n            routeName: initialRouteName\n          });\n        }\n\n        return null;\n      }\n\n      var nestedAction;\n      var nestedQueryString = queryString ? '?' + queryString : '';\n\n      if (childRouters[matchedRouteName]) {\n        nestedAction = childRouters[matchedRouteName].getActionForPathAndParams(pathMatch.slice(pathMatchKeys.length).join('/') + nestedQueryString);\n\n        if (!nestedAction) {\n          return null;\n        }\n      }\n\n      var queryParams = !isEmpty(inputParams) ? inputParams : (queryString || '').split('&').reduce(function (result, item) {\n        if (item !== '') {\n          var nextResult = result || {};\n\n          var _item$split = item.split('='),\n              _item$split2 = _slicedToArray(_item$split, 2),\n              key = _item$split2[0],\n              value = _item$split2[1];\n\n          nextResult[key] = value;\n          return nextResult;\n        }\n\n        return result;\n      }, null);\n      var params = pathMatch.slice(1).reduce(function (result, matchResult, i) {\n        var key = pathMatchKeys[i];\n\n        if (key.asterisk || !key) {\n          return result;\n        }\n\n        var nextResult = result || {};\n        var paramName = key.name;\n        var decodedMatchResult;\n\n        try {\n          decodedMatchResult = decodeURIComponent(matchResult);\n        } catch (e) {}\n\n        nextResult[paramName] = decodedMatchResult || matchResult;\n        return nextResult;\n      }, queryParams);\n      return NavigationActions.navigate(_objectSpread(_objectSpread({\n        routeName: matchedRouteName\n      }, params ? {\n        params: params\n      } : {}), nestedAction ? {\n        action: nestedAction\n      } : {}));\n    },\n    getScreenOptions: createConfigGetter(routeConfigs, stackConfig.navigationOptions),\n    getScreenConfig: getScreenConfigDeprecated\n  };\n});","map":{"version":3,"sources":["/Users/felipe/projects/test-react/node_modules/react-navigation/src/routers/StackRouter.js"],"names":["pathToRegexp","NavigationActions","createConfigGetter","getScreenForRouteName","StateUtils","validateRouteConfigMap","getScreenConfigDeprecated","invariant","generateKey","isEmpty","obj","key","behavesLikePushAction","action","type","NAVIGATE","PUSH","routeConfigs","stackConfig","childRouters","routeNames","Object","keys","forEach","routeName","screen","router","initialRouteParams","initialRouteName","initialChildRouter","pathsByRouteNames","paths","getInitialState","route","childRouter","undefined","childState","childAction","init","params","getStateForAction","isTransitioning","index","routes","navigate","initialRouteKey","pathPattern","path","matchExact","re","toPath","priority","compile","wildcardRe","RegExp","source","entries","sort","a","b","getComponentForState","state","activeChildRoute","getComponentForRouteName","RESET","keyIndex","indexOf","childIndex","childRoute","replaceAt","lastRouteIndex","findIndex","r","slice","find","immediate","push","childRouterNames","i","length","childRouterName","initChildRoute","navigatedChildRoute","routeToPush","POP_TO_TOP","REPLACE","routeIndex","newKey","COMPLETE_TRANSITION","SET_PARAMS","lastRoute","newStackActions","actions","map","newStackAction","BACK","POP","n","backRouteIndex","Math","max","backRoute","getPathAndParamsForState","subPath","stateRoute","child","getActionForPathAndParams","pathToResolve","inputParams","split","pathNameToResolve","queryString","matchedRouteName","pathMatch","pathMatchKeys","exec","nestedAction","nestedQueryString","join","queryParams","reduce","result","item","nextResult","value","matchResult","asterisk","paramName","name","decodedMatchResult","decodeURIComponent","e","getScreenOptions","navigationOptions","getScreenConfig"],"mappings":"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","sourcesContent":["import pathToRegexp from 'path-to-regexp';\n\nimport NavigationActions from '../NavigationActions';\nimport createConfigGetter from './createConfigGetter';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport StateUtils from '../StateUtils';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport getScreenConfigDeprecated from './getScreenConfigDeprecated';\nimport invariant from '../utils/invariant';\nimport { generateKey } from './KeyGenerator';\n\nfunction isEmpty(obj) {\n  if (!obj) return true;\n  for (let key in obj) {\n    return false;\n  }\n  return true;\n}\n\nfunction behavesLikePushAction(action) {\n  return (\n    action.type === NavigationActions.NAVIGATE ||\n    action.type === NavigationActions.PUSH\n  );\n}\n\nexport default (routeConfigs, stackConfig = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const childRouters = {};\n  const routeNames = Object.keys(routeConfigs);\n\n  // Loop through routes and find child routers\n  routeNames.forEach(routeName => {\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen && screen.router) {\n      // If it has a router it's a navigator.\n      childRouters[routeName] = screen.router;\n    } else {\n      // If it doesn't have router it's an ordinary React component.\n      childRouters[routeName] = null;\n    }\n  });\n\n  const { initialRouteParams } = stackConfig;\n\n  const initialRouteName = stackConfig.initialRouteName || routeNames[0];\n\n  const initialChildRouter = childRouters[initialRouteName];\n  const pathsByRouteNames = { ...stackConfig.paths } || {};\n  let paths = [];\n\n  function getInitialState(action) {\n    let route = {};\n    const childRouter = childRouters[action.routeName];\n\n    // This is a push-like action, and childRouter will be a router or null if we are responsible for this routeName\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      let childState = {};\n      // The router is null for normal leaf routes\n      if (childRouter !== null) {\n        const childAction =\n          action.action || NavigationActions.init({ params: action.params });\n        childState = childRouter.getStateForAction(childAction);\n      }\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [\n          {\n            params: action.params,\n            ...childState,\n            key: action.key || generateKey(),\n            routeName: action.routeName,\n          },\n        ],\n      };\n    }\n\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(\n        NavigationActions.navigate({\n          routeName: initialRouteName,\n          params: initialRouteParams,\n        })\n      );\n    }\n    const params = (route.params || action.params || initialRouteParams) && {\n      ...(route.params || {}),\n      ...(action.params || {}),\n      ...(initialRouteParams || {}),\n    };\n    const { initialRouteKey } = stackConfig;\n    route = {\n      ...route,\n      ...(params ? { params } : {}),\n      routeName: initialRouteName,\n      key: action.key || (initialRouteKey || generateKey()),\n    };\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route],\n    };\n  }\n\n  // Build paths for each route\n  routeNames.forEach(routeName => {\n    let pathPattern =\n      pathsByRouteNames[routeName] || routeConfigs[routeName].path;\n    let matchExact = !!pathPattern && !childRouters[routeName];\n    if (pathPattern === undefined) {\n      pathPattern = routeName;\n    }\n    const keys = [];\n    let re, toPath, priority;\n    if (typeof pathPattern === 'string') {\n      // pathPattern may be either a string or a regexp object according to path-to-regexp docs.\n      re = pathToRegexp(pathPattern, keys);\n      toPath = pathToRegexp.compile(pathPattern);\n      priority = 0;\n    } else {\n      // for wildcard match\n      re = pathToRegexp('*', keys);\n      toPath = () => '';\n      matchExact = true;\n      priority = -1;\n    }\n    if (!matchExact) {\n      const wildcardRe = pathToRegexp(`${pathPattern}/*`, keys);\n      re = new RegExp(`(?:${re.source})|(?:${wildcardRe.source})`);\n    }\n    pathsByRouteNames[routeName] = { re, keys, toPath, priority };\n  });\n\n  paths = Object.entries(pathsByRouteNames);\n  paths.sort((a: [string, *], b: [string, *]) => b[1].priority - a[1].priority);\n\n  return {\n    getComponentForState(state) {\n      const activeChildRoute = state.routes[state.index];\n      const { routeName } = activeChildRoute;\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getStateForAction(action, state) {\n      // Set up the initial state if needed\n      if (!state) {\n        return getInitialState(action);\n      }\n\n      // Check if the focused child scene wants to handle the action, as long as\n      // it is not a reset to the root stack\n      if (action.type !== NavigationActions.RESET || action.key !== null) {\n        const keyIndex = action.key\n          ? StateUtils.indexOf(state, action.key)\n          : -1;\n        const childIndex = keyIndex >= 0 ? keyIndex : state.index;\n        const childRoute = state.routes[childIndex];\n        invariant(\n          childRoute,\n          `StateUtils erroneously thought index ${childIndex} exists`\n        );\n        const childRouter = childRouters[childRoute.routeName];\n        if (childRouter) {\n          const route = childRouter.getStateForAction(action, childRoute);\n          if (route === null) {\n            return state;\n          }\n          if (route && route !== childRoute) {\n            return StateUtils.replaceAt(state, childRoute.key, route);\n          }\n        }\n      }\n\n      // Handle explicit push navigation action. This must happen after the\n      // focused child router has had a chance to handle the action.\n      if (\n        behavesLikePushAction(action) &&\n        childRouters[action.routeName] !== undefined\n      ) {\n        const childRouter = childRouters[action.routeName];\n        let route;\n\n        invariant(\n          action.type !== NavigationActions.PUSH || action.key == null,\n          'StackRouter does not support key on the push action'\n        );\n\n        // With the navigate action, the key may be provided for pushing, or to navigate back to the key\n        if (action.key) {\n          const lastRouteIndex = state.routes.findIndex(\n            r => r.key === action.key\n          );\n          if (lastRouteIndex !== -1) {\n            // If index is unchanged and params are not being set, leave state identity intact\n            if (state.index === lastRouteIndex && !action.params) {\n              return state;\n            }\n\n            // Remove the now unused routes at the tail of the routes array\n            const routes = state.routes.slice(0, lastRouteIndex + 1);\n\n            // Apply params if provided, otherwise leave route identity intact\n            if (action.params) {\n              const route = state.routes.find(r => r.key === action.key);\n              routes[lastRouteIndex] = {\n                ...route,\n                params: {\n                  ...route.params,\n                  ...action.params,\n                },\n              };\n            }\n            // Return state with new index. Change isTransitioning only if index has changed\n            return {\n              ...state,\n              isTransitioning:\n                state.index !== lastRouteIndex\n                  ? action.immediate !== true\n                  : undefined,\n              index: lastRouteIndex,\n              routes,\n            };\n          }\n        }\n\n        if (childRouter) {\n          const childAction =\n            action.action || NavigationActions.init({ params: action.params });\n          route = {\n            params: action.params,\n            // merge the child state in this order to allow params override\n            ...childRouter.getStateForAction(childAction),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        } else {\n          route = {\n            params: action.params,\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        }\n        return {\n          ...StateUtils.push(state, route),\n          isTransitioning: action.immediate !== true,\n        };\n      } else if (\n        action.type === NavigationActions.PUSH &&\n        childRouters[action.routeName] === undefined\n      ) {\n        // If we've made it this far with a push action, we return the\n        // state with a new identity to prevent the action from bubbling\n        // back up.\n        return {\n          ...state,\n        };\n      }\n\n      // Handle navigation to other child routers that are not yet pushed\n      if (behavesLikePushAction(action)) {\n        const childRouterNames = Object.keys(childRouters);\n        for (let i = 0; i < childRouterNames.length; i++) {\n          const childRouterName = childRouterNames[i];\n          const childRouter = childRouters[childRouterName];\n          if (childRouter) {\n            // For each child router, start with a blank state\n            const initChildRoute = childRouter.getStateForAction(\n              NavigationActions.init()\n            );\n            // Then check to see if the router handles our navigate action\n            const navigatedChildRoute = childRouter.getStateForAction(\n              action,\n              initChildRoute\n            );\n            let routeToPush = null;\n            if (navigatedChildRoute === null) {\n              // Push the route if the router has 'handled' the action and returned null\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              // Push the route if the state has changed in response to this navigation\n              routeToPush = navigatedChildRoute;\n            }\n            if (routeToPush) {\n              const route = {\n                ...routeToPush,\n                routeName: childRouterName,\n                key: action.key || generateKey(),\n              };\n              return StateUtils.push(state, route);\n            }\n          }\n        }\n      }\n\n      // Handle pop-to-top behavior. Make sure this happens after children have had a chance to handle the action, so that the inner stack pops to top first.\n      if (action.type === NavigationActions.POP_TO_TOP) {\n        // Refuse to handle pop to top if a key is given that doesn't correspond\n        // to this router\n        if (action.key && state.key !== action.key) {\n          return state;\n        }\n\n        // If we're already at the top, then we return the state with a new\n        // identity so that the action is handled by this router.\n        if (state.index === 0) {\n          return {\n            ...state,\n          };\n        } else {\n          return {\n            ...state,\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]],\n          };\n        }\n        return state;\n      }\n\n      // Handle replace action\n      if (action.type === NavigationActions.REPLACE) {\n        const routeIndex = state.routes.findIndex(r => r.key === action.key);\n        // Only replace if the key matches one of our routes\n        if (routeIndex !== -1) {\n          const childRouter = childRouters[action.routeName];\n          let childState = {};\n          if (childRouter) {\n            const childAction =\n              action.action ||\n              NavigationActions.init({ params: action.params });\n            childState = childRouter.getStateForAction(childAction);\n          }\n          const routes = [...state.routes];\n          routes[routeIndex] = {\n            params: action.params,\n            // merge the child state in this order to allow params override\n            ...childState,\n            routeName: action.routeName,\n            key: action.newKey || generateKey(),\n          };\n          return { ...state, routes };\n        }\n      }\n\n      // Update transitioning state\n      if (\n        action.type === NavigationActions.COMPLETE_TRANSITION &&\n        (action.key == null || action.key === state.key) &&\n        state.isTransitioning\n      ) {\n        return {\n          ...state,\n          isTransitioning: false,\n        };\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n\n      if (action.type === NavigationActions.RESET) {\n        // Only handle reset actions that are unspecified or match this state key\n        if (action.key != null && action.key != state.key) {\n          // Deliberately use != instead of !== so we can match null with\n          // undefined on either the state or the action\n          return state;\n        }\n        const newStackActions = action.actions;\n\n        return {\n          ...state,\n          routes: newStackActions.map(newStackAction => {\n            const router = childRouters[newStackAction.routeName];\n\n            let childState = {};\n\n            if (router) {\n              const childAction =\n                newStackAction.action ||\n                NavigationActions.init({ params: newStackAction.params });\n\n              childState = router.getStateForAction(childAction);\n            }\n\n            return {\n              params: newStackAction.params,\n              ...childState,\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || generateKey(),\n            };\n          }),\n          index: action.index,\n        };\n      }\n\n      if (\n        action.type === NavigationActions.BACK ||\n        action.type === NavigationActions.POP\n      ) {\n        const { key, n, immediate } = action;\n        let backRouteIndex = state.index;\n        if (action.type === NavigationActions.POP && n != null) {\n          // determine the index to go back *from*. In this case, n=1 means to go\n          // back from state.index, as if it were a normal \"BACK\" action\n          backRouteIndex = Math.max(1, state.index - n + 1);\n        } else if (key) {\n          const backRoute = state.routes.find(route => route.key === key);\n          backRouteIndex = state.routes.indexOf(backRoute);\n        }\n\n        if (backRouteIndex > 0) {\n          return {\n            ...state,\n            routes: state.routes.slice(0, backRouteIndex),\n            index: backRouteIndex - 1,\n            isTransitioning: immediate !== true,\n          };\n        } else if (\n          backRouteIndex === 0 &&\n          action.type === NavigationActions.POP\n        ) {\n          return {\n            ...state,\n          };\n        }\n      }\n      return state;\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      const routeName = route.routeName;\n      const screen = getScreenForRouteName(routeConfigs, routeName);\n      const subPath = pathsByRouteNames[routeName].toPath(route.params);\n      let path = subPath;\n      let params = route.params;\n      if (screen && screen.router) {\n        const stateRoute = route;\n        // If it has a router it's a navigator.\n        // If it doesn't have router it's an ordinary React component.\n        const child = screen.router.getPathAndParamsForState(stateRoute);\n        path = subPath ? `${subPath}/${child.path}` : child.path;\n        params = child.params ? { ...params, ...child.params } : params;\n      }\n      return {\n        path,\n        params,\n      };\n    },\n\n    getActionForPathAndParams(pathToResolve, inputParams) {\n      // If the path is empty (null or empty string)\n      // just return the initial route action\n      if (!pathToResolve) {\n        return NavigationActions.navigate({\n          routeName: initialRouteName,\n        });\n      }\n\n      const [pathNameToResolve, queryString] = pathToResolve.split('?');\n\n      // Attempt to match `pathNameToResolve` with a route in this router's\n      // routeConfigs\n      let matchedRouteName;\n      let pathMatch;\n      let pathMatchKeys;\n\n      // eslint-disable-next-line no-restricted-syntax\n      for (const [routeName, path] of paths) {\n        const { re, keys } = path;\n        pathMatch = re.exec(pathNameToResolve);\n        if (pathMatch && pathMatch.length) {\n          pathMatchKeys = keys;\n          matchedRouteName = routeName;\n          break;\n        }\n      }\n\n      // We didn't match -- return null\n      if (!matchedRouteName) {\n        // If the path is empty (null or empty string)\n        // just return the initial route action\n        if (!pathToResolve) {\n          return NavigationActions.navigate({\n            routeName: initialRouteName,\n          });\n        }\n        return null;\n      }\n\n      // Determine nested actions:\n      // If our matched route for this router is a child router,\n      // get the action for the path AFTER the matched path for this\n      // router\n      let nestedAction;\n      let nestedQueryString = queryString ? '?' + queryString : '';\n      if (childRouters[matchedRouteName]) {\n        nestedAction = childRouters[matchedRouteName].getActionForPathAndParams(\n          pathMatch.slice(pathMatchKeys.length).join('/') + nestedQueryString\n        );\n        if (!nestedAction) {\n          return null;\n        }\n      }\n\n      // reduce the items of the query string. any query params may\n      // be overridden by path params\n      const queryParams = !isEmpty(inputParams)\n        ? inputParams\n        : (queryString || '').split('&').reduce((result, item) => {\n            if (item !== '') {\n              const nextResult = result || {};\n              const [key, value] = item.split('=');\n              nextResult[key] = value;\n              return nextResult;\n            }\n            return result;\n          }, null);\n\n      // reduce the matched pieces of the path into the params\n      // of the route. `params` is null if there are no params.\n      const params = pathMatch.slice(1).reduce((result, matchResult, i) => {\n        const key = pathMatchKeys[i];\n        if (key.asterisk || !key) {\n          return result;\n        }\n        const nextResult = result || {};\n        const paramName = key.name;\n\n        let decodedMatchResult;\n        try {\n          decodedMatchResult = decodeURIComponent(matchResult);\n        } catch (e) {\n          // ignore `URIError: malformed URI`\n        }\n\n        nextResult[paramName] = decodedMatchResult || matchResult;\n        return nextResult;\n      }, queryParams);\n\n      return NavigationActions.navigate({\n        routeName: matchedRouteName,\n        ...(params ? { params } : {}),\n        ...(nestedAction ? { action: nestedAction } : {}),\n      });\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      stackConfig.navigationOptions\n    ),\n\n    getScreenConfig: getScreenConfigDeprecated,\n  };\n};\n"]},"metadata":{},"sourceType":"module"}